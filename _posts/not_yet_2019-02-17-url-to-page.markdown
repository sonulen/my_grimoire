---
title:  "От ввода URL до прогрузки web-страницы"
date:   2019-02-23 19:11:23
categories: [network]
tags: [dns] [http] [web browser]
---
[en.cppreference.com]: https://en.cppreference.com/w/

Что происходит когда вы печатаете в адресной строке url сайта и нажимаете Enter?
Попытаемся разобраться в этом, на примере загрузки сайта [en.cppreference.com][].

## 1. Фокус на строке ввода url и введена первая буква **с**

Не рассматриваются работа клавиатуры, прерывания ОС и обработка нажатия клавиш, но и помимо этого много чего происходит. Когда вы нажимаете клавишу «c», браузер получает событие и запускается механизм автоподстановки. В зависимости от алгоритма браузера и его режима (включена ли функция «инкогнито») в выпадающем окне под строкой URL пользователю будет предложено определённое количество вариантов для автоподстановки.

Большинство алгоритмов автоподстановки ранжируют рекомендации в зависимости от истории поиска и оставленных закладках. Некоторые браузеры (например, Rockmelt) даже предлагают профили друзей на Facebook.

Рекомендации будут обновляться с каждой новой напечатанной буквой. Возможно, браузер предложит перейти на сайт, до того, как пользователь вобьёт адрес целиком.

## 2. Клавиша «enter» нажата до конца

В качестве некой нулевой точки можно выбрать момент, когда клавиша Enter на клавиатуре нажата до конца и находится в нижнем положении. В этой точке замыкается электрическая цепь этой клавиши и небольшое количество тока отправляется по электросхеме клавиатуры, которая сканирует состояние каждого переключателя клавиши и конвертирует сигнал в целочисленный код клавиши (в данном случае — 13). Затем контроллер клавиатуры конвертирует код клавиши для передачи его компьютеру. Как правило, сейчас передача происходит через USB или Bluetooth, а раньше клавиатура подключалась к компьютеру с помощью коннекторов PS/2 или ADB.

### В случае USB-клавиатуры:

Для работы USB-контуру клавиатуры требуется 5 вольт питания, которые поступают через USB-контроллер на компьютере.
Сгенерированный код клавиши хранится в регистре внутренней памяти клавиатуры, который называется «конечной точкой» (endpoint).
USB-контроллер компьютера опрашивает эту конечную точку каждые 10 микросекунд и получает хранящийся там код клавиши.
Затем это значение поступает в USB SIE (Serial Interface Engine) для конвертации в один или более USB-пакетов, которые формируются по низкоуровневому протоколу USB.
Эти пакеты затем пересылаются с помощью различных электрических сигналов через D+ и D- контакты с максимальной скоростью 1,5 Мб/сек — поскольку HID-устройства (Human Interface Device) всегда были «низкоскоростными».
Этот последовательный сигнал далее декодируется в USB-контроллере компьютера и интерпретируется универсальным драйвером HID-устройства (клавиатуры). Затем значение кода клавиши передаётся на «железный» уровень абстракции операционной системы.

### Возникло прерывание [не для USB-клавиатур]

Клавиатура отправляет сигналы в свою «линию запросов прерываний» (IRQ), которая затем сопоставляется с «вектором прерывания» (целое число) контроллером прерываний. Процессор использует «таблицу дескрипторов прерываний» (IDT) для сопоставления векторов прерываний с функциями («обработчики прерываний») ядра. Когда появляется прерывание, процессор (CPU) обновляет IDT вектором прерывания и запускает соответствующий обработчик. Таким образом, в дело вступает ядро.

### (В GNU/Linux) Сервер Xorg слушает клавиатурные коды

В случае графического X server, для получения нажатия клавиши будет использован общий драйвер событий evdev. Переназначение клавиатурных кодов скан-кодам осуществляется с помощью специальных правил и карт X Server. Когда маппинг скан-кода нажатой клавиши завершён, X server посылает символ в window manager (DWM, metacity, i3), который затем отправляет его в активное окно. Графический API окна, получившего символ, печатает соответствующий символ шрифта в нужном поле.

## 3. Парсинг URL

Теперь у браузера есть следующая информация об URL:

```
Protocol «HTTP»
Использовать «Hyper Text Transfer Protocol»

Resource «/»
Показать главную (индексную) страницу
```

### 3.1 Это URL или поисковый запрос?

Когда пользователь не вводит протокол или доменное имя, то браузер «скармливает» то, что человек напечатал, поисковой машине, установленной по умолчанию. Часто к URL добавляется специальный текст, который позволяет поисковой машине понять, что информация передана из URL-строки определённого браузера.

### 3.2 Список проверки HSTS

Браузер проверяет список «предзагруженных HSTS (HTTP Strict Transport Security)». Это список сайтов, которые требуют, чтобы к ним обращались только по HTTPS.
Если нужный сайт есть в этом списке, то браузер отправляет ему запрос через HTTPS вместо HTTP. В противном случае, начальный запрос посылается по HTTP. (При этом сайт может использовать политику HSTS, но не находиться в списке HSTS — в таком случае на первый запрос по HTTP будет отправлен ответ о том, что необходимо отправлять запросы по HTTPS. Однако это может сделать пользователя уязвимым к downgrade-атакам — чтобы этого избежать, в браузеры и включают список HSTS).  
Например при запросе страницы [http://en.cppreference.com](http://en.cppreference.com) (80 порт) в ответ будет получен redirect **302 Found** :

```bash
$ curl -s -D- http://en.cppreference.com/
HTTP/1.1 302 Found
Date: Sat, 23 Feb 2019 13:27:26 GMT
Server: Apache
Location: https://en.cppreference.com/w/
Cache-Control: max-age=2592000
Expires: Mon, 25 Mar 2019 13:27:26 GMT
Content-Length: 214
Content-Type: text/html; charset=iso-8859-1

<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0//EN">
<html><head>
<title>302 Found</title>
</head><body>
<h1>Found</h1>
<p>The document has moved <a href="https://en.cppreference.com/w/">here</a>.</p>
</body></html>
```

Инициирующий установление TLS соединения через 443 порт.

### 3.3 Конвертация не-ASCII Unicode символов в название хоста

Браузер проверяет имя хоста на наличие символов, отличных от a-z, A-Z, 0-9, -, или ..
В случае доменного имени [en.cppreference.com][] никаких проблем не будет, но если бы домен содержал не-ASCII символы, то браузер бы применил кодировку Punycode для этой части URL.

## 4. Определение DNS

* Браузер проверяет наличие домена в своём кэше.
* Если домена там нет, то браузер вызывает библиотечную функцию gethostbyname (отличается в разных ОС) для поиска нужного адреса.  
  Для этого (например в Centos7, ubuntu 18 и подобных) используются конфигурация описанная в файле nsswitch.conf:

  ```bash
  $ grep ^hosts /etc/nsswitch.conf
  hosts:      files mdns4_minimal dns
  ```
**files**, **dns** и **myhostname** являются алиасами баз данных для поиска. **files** на большинстве систем подразумевает использование `/etc/hosts`, **dns** база — это DNS-сервер к которому будет осуществляться запрос поиска hostname, а **myhostname** — это самая необычная база, о существовании которой мало кто знает и она не является частью стандартной поставки в **glibc**. В некоторых дистрибутивах присутствует еще и база **mdns4_minimal**.

* Прежде, чем искать домен по DNS gethostbyname пытается найти нужный адрес в файле hosts (его расположение отличается в разных ОС).
  Пример файла взятый с **ubuntu 18**:
  ```bash
  $ cat /etc/hosts
  127.0.0.1	localhost
  127.0.1.1	username-pc

  # The following lines are desirable for IPv6 capable hosts
  ::1     ip6-localhost ip6-loopback
  fe00::0 ip6-localnet
  ff00::0 ip6-mcastprefix
  ff02::1 ip6-allnodes
  ff02::2 ip6-allrouters
  ```

* Если домен нигде не закэширован и отсутствует в файле hosts, gethostbyname отправляет запрос к сетевому DNS-серверу. Как правило, это локальный роутер или DNS-сервер интернет-провайдера.  
  База **dns** при определении адреса использует name server указанный в конфиге `/etc/resolv.conf`. Пример конфигурационного файла:

  ```bash
  $ cat /etc/resolv.conf

  nameserver 127.0.0.53
  options edns0
  search aviel.ru
  ```
* Если DNS-сервер находится в той же подсети, то ARP-запрос отправляется этому серверу.
* Если DNS-сервер находится в другой подсети, то ARP-запрос отправляется на IP-адрес шлюза по умолчанию (default gateway).

### 4.1 Процесс отправки ARP-запроса

Для того, чтобы отправить широковещательный ARP-запрос необходимо отыскать целевой IP-адрес, а также знать MAC - адрес интерфейса, который будет использоваться для отправки ARP-запроса.

Кэш ARP проверяется для каждого целевого IP-адреса — если адрес есть в кэше, то библиотечная функция возвращает результат: Target IP = MAC.

Если же записи в кэше нет:

* Проверяется таблица маршрутизации — это делается для того, чтобы узнать, есть ли искомый IP-адрес в какой-либо из подсетей локальной таблицы. Если он там, то запрос посылается с помощью интерфейса, связанного с этой подсетью. Если адрес в таблице не обнаружен, то используется интерфейс подсети шлюза по умолчанию.
* Определяется MAC-адрес выбранного сетевого интерфейса.
* Отправляется ARP-запрос (второй уровень стека):

ARP-запрос:
```bash
Sender MAC: interface:mac:address:here
Sender IP: interface.ip.goes.here
Target MAC: FF:FF:FF:FF:FF:FF (Broadcast)
Target IP: target.ip.goes.here
```
В зависимости от того, какое «железо» расположено между компьютером и роутером (маршрутизатором):

Прямое соединение:

* Если компьютер напрямую подключён к роутеру, то это устройство отправляет ARP-ответ (ARP Reply).

Между ними концентратор (Хаб):

* Если компьютер подключён к сетевому концентратору, то этот хаб отправляет широковещательный ARP-запрос со всех своих портов. Если роутер подключён по тому же «проводу», то отправит ARP-ответ.

Между ними коммутатор (свитч):

* Если компьютер соединён с сетевым коммутатором, то этот свитч проверит локальную CAM/MAC-таблицу, чтобы узнать, какой порт в ней имеет нужный MAC-адрес. Если нужного адреса в таблице нет, то он заново отправит широковещательный ARP-запрос по всем портам.
* Если в таблице есть нужная запись, то свитч отправит ARP-запрос на порт с искомым MAC-адресом.
* Если роутер «на одной линии» со свитчем, то он ответит (ARP Reply).

ARP-ответ:
```bash
Sender MAC: target:mac:address:here
Sender IP: target.ip.goes.here
Target MAC: interface:mac:address:here
Target IP: interface.ip.goes.here
```
Теперь у сетевой библиотеки есть IP-адрес либо DNS-сервера либо шлюза по умолчанию, который можно использовать для разрешения доменного имени:

* Порт 53 открывается для отправки UDP-запроса к DNS-серверу (если размер ответа слишком велик, будет использован TCP).
* Если локальный или на стороне провайдера DNS-сервер «не знает» нужный адрес, то запрашивается рекурсивный поиск, который проходит по списку вышестоящих DNS-серверов, пока не будет найдена SOA-запись, а затем возвращается результат.

## 5. Открытие сокета

Когда браузер получает IP-адрес конечного сервера, то он берёт эту информацию и данные об используемом порте из URL (80 порт для HTTP, 443 для HTTPS) и осуществляет вызов функции socket системной библиотеки и запрашивает поток TCP сокета — *AF_INET* и *SOCK_STREAM*.

Этот запрос сначала проходит через транспортный уровень, где собирается TCP-сегмент. В заголовок добавляется порт назначения, исходный порт выбирается из динамического пула ядра (ip_local_port_range в Linux).  

Получившийся сегмент отправляется на сетевой уровень, на котором добавляется дополнительный IP-заголовок. Также включаются IP-адрес сервера назначения и адрес текущей машины — после этого пакет сформирован.  

Пакет передаётся на канальный уровень. Добавляется заголовок кадра, включающий MAC-адрес сетевой карты (NIC) компьютера, а также MAC-адрес шлюза (локального роутера). Как и на предыдущих этапах, если ядру ничего не известно о MAC-адресе шлюза, то для его нахождения отправляется широковещательный ARP-запрос.

На этой точке пакет готов к передаче через:

* Ethernet
* WiFi
* По сотовой связи

В случае интернет-соединения большинства частных пользователей или небольших компаний пакет будет отправлен с компьютера, через локальную сеть, а затем через модем (MOdulator/DEModulator), который транслирует цифровые единицы и нули в аналоговый сигнал, подходящий для передачи по телефонной линии, кабелю или беспроводным телефонным соединениям. На другой стороне соединения расположен другой модем, который конвертирует аналоговый сигнал в цифровые данные и передаёт их следующему сетевому узлу, где происходит дальнейший анализ данных об отправителе и получателе.

В конечном итоге пакет доберётся до маршрутизатора, управляющего локальной подсетью. Затем он продолжит путешествовать от одного роутера к другому, пока не доберётся до сервера назначения. Каждый маршрутизатор на пути будет извлекать адрес назначения из IP-заголовка и отправлять пакет на следующий хоп.   

Значение поля TTL (time to live) в IP-заголовке будет каждый раз уменьшаться после прохождения каждого роутера. Если значение поля TTL достигнет нуля, пакет будет отброшен (это произойдёт также если у маршрутизатора не будет места в текущей очереди — например, из-за перегрузки сети).

Во время TCP-соединения происходит множество подобных запросов и ответов.

### 5.1 Жизненный цикл TCP-соединения

**a**. Клиент выбирает номер начальной последовательности (ISN) и отправляет пакет серверу с установленным битом SYN для открытия соединения.

**b**. Сервер получает пакет с битом SYN и, если готов к установлению соединения, то:

* Выбирает собственный номер начальной последовательности;
* Устанавливает SYN-бит, чтобы сообщить о выборе начальной последовательности;
* Копирует ISN клиента +1 в поле ACK и добавляет ACK-флаг для обозначения подтверждения получения первого пакета.

<div style="text-align:center"><img src ="../images/posts_includes/url_to_page/syn.png" width="100%" height="100%" /></div>

**c**. Клиент подтверждает соединение путём отправки пакета:

* Увеличивает номер своей начальной последовательности;
* Увеличивает номер подтверждения получения;
* Устанавливает поле ACK.

<div style="text-align:center"><img src ="../images/posts_includes/url_to_page/syn_ack.png" width="100%" height="100%" /></div>

**d**. Данные передаются следующим образом:

* Когда одна сторона отправляет N байтов, то увеличивает значение поля SEQ на это число.
* Когда вторая сторона подтверждает получение этого пакета (или цепочки пакетов), она отправляет пакет ACK, в котором значение поля ACK равняется последней полученной последовательности.

**e**. Закрытие соединения:

* Сторона, которая хочет закрыть соединение, отправляет пакет FIN;
* Другая сторона подтверждает FIN (с помощью ACK) и отправляет собственный FIN-пакет;
* Инициатор прекращения соединения подтверждает получение FIN отправкой собственного ACK и RST для прекращения попыток переподключения.

<div style="text-align:center"><img src ="../images/posts_includes/url_to_page/fin_ack.png" width="100%" height="100%" /></div>

## 6. TLS handshake

**a**. Клиентский компьютер отправляет сообщение ClientHello серверу со своей версией протокола TLS, списком поддерживаемых алгоритмов шифрования и методов компрессии данных.

**b**. Сервер отвечает клиенту сообщением ServerHello, содержащим версию TLS, выбранный метод шифрования, выбранные методы компрессии и публичный сертификат сервиса, подписанный центром сертификации. Сертификат содержит публичный ключ, который будет использоваться клиентом для шифрования оставшейся части процедуры «рукопожатия» (handshake), пока не будет согласован симметричный ключ.

**c**. Клиент подтверждает сертификат сервера с помощью своего списка центров сертификации. Если сертификат подписан центром из списка, то серверу можно доверять, и клиент генерирует строку псевдослучайных байтов и шифрует её с помощью публичного ключа сервера. Эти случайные байты могут быть использованы для определения симметричного ключа.

**d**. Сервер расшифровывает случайные байты с помощью своего секретного ключа и использует эти байты для генерации своей копии симметричного мастер-ключа.

**e**. Клиент отправляет серверу сообщение Finished, шифруя хеш передачи с помощью симметричного ключа.

**f**. Сервер генерирует собственный хеш, а затем расшифровывает полученный от клиента хеш, чтобы проверить, совпадёт ли он с собственным. Если совпадение обнаружено, сервер отправляет клиенту собственный ответ Finished, также зашифрованный симметричным ключом.

**g**. После этого TLS-сессия передаёт данные приложения (HTTP), зашифрованные с помощью подтверждённого симметричного ключа.

Пример TLS соединения при загрузке страницы [en.cppreference.com][]:

<div style="text-align:center"><img src ="../images/posts_includes/url_to_page/tls.png" width="100%" height="100%" /></div>
